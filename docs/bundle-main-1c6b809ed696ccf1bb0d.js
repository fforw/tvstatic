var Demo=function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=2)}([function(e,n,t){},,function(e,n,t){"use strict";t.r(n);t(0);Math.sqrt(5),Math.PI;var r,o,i,a,f,c,l,d,u={width:0,height:0},v=new Float32Array(6),s=0;function g(e){v[0]=.0031*e,v[1]=-7e-4*e,v[2]=s,v[3]=s+100,v[4]=.02*Math.cos(.04*e)+.06,v[5]=.45+.25*Math.sin(3e-4*e)+.15*Math.cos(5e-4*e),s=.1*e%u.height,o.uniform1f(i,e),o.uniform1fv(a,v),o.uniform1f(f,u.width),o.uniform1f(c,u.height),o.drawElements(o.TRIANGLES,m.length,o.UNSIGNED_SHORT,0),requestAnimationFrame(g)}var h=[-1,1,0,-1,-1,0,1,-1,0,1,1,0],m=[3,2,1,3,1,0];function x(e){var n=-16&window.innerWidth,t=0|window.innerHeight;u.width=n,u.height=t,r.width=n,r.height=t,o.viewport(0,0,r.width,r.height)}window.onload=function(){return(e="media/tv.png",new Promise((function(n,t){var r=new Image;r.src=e,r.onload=function(){return n(r)},r.onerror=t}))).then((function(e){console.log("TEST",e,e.width,e.height),r=document.getElementById("screen");var n=-16&window.innerWidth,t=0|window.innerHeight;u.width=n,u.height=t,r.width=n,r.height=t;var v=(o=r.getContext("webgl")).createBuffer();o.bindBuffer(o.ARRAY_BUFFER,v),o.bufferData(o.ARRAY_BUFFER,new Float32Array(h),o.STATIC_DRAW),o.bindBuffer(o.ARRAY_BUFFER,null);var s=o.createBuffer();o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,s),o.bufferData(o.ELEMENT_ARRAY_BUFFER,new Uint16Array(m),o.STATIC_DRAW),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,null);var w=o.createShader(o.VERTEX_SHADER);o.shaderSource(w,"#define GLSLIFY 1\nattribute vec3 coordinates;\nvoid main(void) {\n    gl_Position = vec4(coordinates, 1.0);\n}\n"),o.compileShader(w);var E=o.createShader(o.FRAGMENT_SHADER);o.shaderSource(E,"precision mediump float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float wave[6];\nuniform float width;\nuniform float height;\n\nuniform sampler2D testImage;\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat noise(vec2 v){\n    float value = snoise(v);\n    if (v.x > -2.0 && v.x < 2.0)\n    {\n        value *= 0.2;\n    }\n    return value;\n}\n\nvoid main(void) {\n\n    //float signalToNoise = 0.5;\n    float signalToNoise = wave[5];\n    float colorOffset = 0.7;\n\n    float n0 = noise(vec2(time * 0.17,time * 0.31));\n    float offset = n0 * 100.0;\n\n    float y = gl_FragCoord.y/gl_FragCoord.w;\n\n    float hOff = -50.0 + 50.0 * sin(wave[0] + y * 0.01) + 33.0 * sin(wave[1] + y * (y >= wave[2] && y <= wave[3] ? wave[4]: 0.013));\n\n    float x = (gl_FragCoord.x + hOff)/gl_FragCoord.w;\n\n    vec3 noiseColor = vec3(\n        noise(vec2(x * 0.2 + offset, y * 0.2) - offset),\n        noise(vec2(x * 0.2 + offset + colorOffset, y * 0.2) - offset),\n        noise(vec2(x * 0.2 + offset, y * 0.2) - offset + colorOffset)\n    );\n\n    float tx = ((gl_FragCoord.x + hOff) / width);\n    float ty = 1.0 - (gl_FragCoord.y / height);\n\n    gl_FragColor = vec4(noiseColor * (1.0 - signalToNoise) + texture2D(testImage, vec2(tx,ty)).xyz * signalToNoise, 1);\n}\n\n"),o.compileShader(E);var T=!1;if(o.getShaderParameter(w,o.COMPILE_STATUS)||(console.error("Invalid vertex shader",o.getShaderInfoLog(w)),T=!0),o.getShaderParameter(E,o.COMPILE_STATUS)||(console.error("Invalid fragment shader",o.getShaderInfoLog(E)),T=!0),!T){var y=o.createProgram();if(o.attachShader(y,w),o.attachShader(y,E),o.linkProgram(y),o.getProgramParameter(y,o.LINK_STATUS)){i=o.getUniformLocation(y,"time"),a=o.getUniformLocation(y,"wave"),l=o.getUniformLocation(y,"testImage"),f=o.getUniformLocation(y,"width"),c=o.getUniformLocation(y,"height"),o.useProgram(y),o.bindBuffer(o.ARRAY_BUFFER,v),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,s);var _=o.getAttribLocation(y,"coordinates");o.vertexAttribPointer(_,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(_),o.clearColor(0,0,0,1),o.enable(o.DEPTH_TEST),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT),o.viewport(0,0,r.width,r.height),d=o.createTexture(),o.bindTexture(o.TEXTURE_2D,d),o.texImage2D(o.TEXTURE_2D,0,o.RGBA,o.RGBA,o.UNSIGNED_BYTE,e),o.generateMipmap(o.TEXTURE_2D),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,d),o.uniform1i(l,0),window.addEventListener("resize",x,!0),requestAnimationFrame(g)}else console.error(o.getProgramInfoLog(y))}}));var e}}]);
//# sourceMappingURL=bundle-main-1c6b809ed696ccf1bb0d.js.map